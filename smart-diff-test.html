<!DOCTYPE html>
<html>
<head>
    <title>Smart Diff Test - Export Report</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        .controls {
            margin: 20px 0;
            padding: 20px;
            background: #f5f5f5;
            border: 2px solid #333;
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.processing {
            background: #fff3cd;
            color: #856404;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>🔬 Smart Excel Diff Test</h1>
    
    <div class="controls">
        <input type="file" id="originalFile" accept=".xlsx">
        <button onclick="runSmartDiff()">Run Analysis</button>
        <button onclick="downloadReport()" id="downloadBtn" style="display:none;">Download Report</button>
    </div>

    <div id="status" class="status processing">Select test.xlsx to begin...</div>
    
    <pre id="preview"></pre>

    <script src="dist/luckyexcel.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        let reportContent = '';
        let originalData = null;
        let importedData = null;
        let exportedData = null;

        function setStatus(message, type = 'processing') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        async function runSmartDiff() {
            const file = document.getElementById('originalFile').files[0];
            if (!file) {
                alert('Please select an Excel file first');
                return;
            }

            reportContent = '';
            setStatus('Analyzing Excel file...', 'processing');
            
            try {
                // Step 1: Read original
                originalData = await readExcelWithXLSX(file);
                
                // Step 2: Import with our library
                await new Promise((resolve, reject) => {
                    LuckyExcel.transformExcelToUniver(
                        file,
                        function(univerData) {
                            importedData = univerData;
                            resolve();
                        },
                        reject
                    );
                });

                // Step 3: Export back
                await new Promise((resolve, reject) => {
                    LuckyExcel.transformUniverToExcel({
                        snapshot: importedData,
                        getBuffer: true,
                        success: function(buffer) {
                            const blob = new Blob([buffer], {
                                type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                            });
                            readExcelWithXLSX(blob).then(data => {
                                exportedData = data;
                                resolve();
                            });
                        },
                        error: reject
                    });
                });

                // Generate smart report
                generateSmartReport();
                
                setStatus('✅ Analysis complete! Report ready for download.', 'success');
                document.getElementById('downloadBtn').style.display = 'inline-block';
                
            } catch (error) {
                console.error('Error:', error);
                setStatus(`❌ Error: ${error.message}`, 'error');
            }
        }

        function readExcelWithXLSX(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = e.target.result;
                        const workbook = XLSX.read(data, {
                            type: 'binary',
                            cellFormula: true,
                            cellStyles: true
                        });
                        
                        const sheets = {};
                        workbook.SheetNames.forEach(sheetName => {
                            const worksheet = workbook.Sheets[sheetName];
                            sheets[sheetName] = parseSheet(worksheet);
                        });
                        
                        resolve({
                            sheetNames: workbook.SheetNames,
                            sheets: sheets
                        });
                    } catch (err) {
                        reject(err);
                    }
                };
                if (file instanceof Blob) {
                    reader.readAsBinaryString(file);
                } else {
                    reader.readAsBinaryString(file);
                }
            });
        }

        function parseSheet(worksheet) {
            const cells = {};
            const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
            
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({r: row, c: col});
                    const cell = worksheet[cellAddress];
                    
                    if (cell && cell.f) { // Only store cells with formulas for efficiency
                        const cellKey = `${row}_${col}`;
                        cells[cellKey] = {
                            value: cell.v,
                            formula: cell.f,
                            address: cellAddress
                        };
                    }
                }
            }
            return { cells: cells };
        }

        function getUniverCellData(sheet, row, col) {
            if (!sheet.cellData || !sheet.cellData[row] || !sheet.cellData[row][col]) {
                return null;
            }
            const cell = sheet.cellData[row][col];
            return {
                value: cell.v,
                formula: cell.f
            };
        }

        function generateSmartReport() {
            let report = [];
            report.push('EXCEL IMPORT/EXPORT DIFFERENCE REPORT');
            report.push('=' .repeat(50));
            report.push(`Generated: ${new Date().toISOString()}`);
            report.push('');
            
            // Track patterns of issues
            const issuePatterns = {
                missingFormulas: [],
                changedFormulas: [],
                sharedFormulaIssues: [],
                chooseFormulaIssues: [],
                absoluteRefIssues: [],
                otherIssues: []
            };
            
            // Analyze each sheet
            originalData.sheetNames.forEach(sheetName => {
                const origSheet = originalData.sheets[sheetName];
                const univerSheet = Object.values(importedData.sheets).find(s => s.name === sheetName);
                const expSheet = exportedData ? exportedData.sheets[sheetName] : null;
                
                if (!univerSheet) {
                    issuePatterns.otherIssues.push(`Sheet "${sheetName}" missing in import`);
                    return;
                }
                
                // Check formulas
                Object.keys(origSheet.cells).forEach(cellKey => {
                    const [row, col] = cellKey.split('_').map(Number);
                    const origCell = origSheet.cells[cellKey];
                    const impCell = getUniverCellData(univerSheet, row, col);
                    const expCell = expSheet ? expSheet.cells[cellKey] : null;
                    
                    if (origCell.formula) {
                        const origFormula = origCell.formula;
                        const impFormula = impCell ? impCell.formula : null;
                        const expFormula = expCell ? expCell.formula : null;
                        
                        // Categorize issues
                        if (!impFormula) {
                            issuePatterns.missingFormulas.push({
                                sheet: sheetName,
                                cell: origCell.address,
                                original: origFormula
                            });
                        } else if (impFormula !== origFormula || expFormula !== origFormula) {
                            // Check for specific patterns
                            if (origFormula.includes('CHOOSE')) {
                                issuePatterns.chooseFormulaIssues.push({
                                    sheet: sheetName,
                                    cell: origCell.address,
                                    original: origFormula,
                                    imported: impFormula,
                                    exported: expFormula
                                });
                            } else if (origFormula.includes('$')) {
                                // Check for absolute reference corruption
                                const absRefs = origFormula.match(/\$[A-Z]+\$?\d+/g) || [];
                                const impAbsRefs = impFormula ? (impFormula.match(/\$[A-Z]+\$?\d+/g) || []) : [];
                                
                                if (absRefs.join(',') !== impAbsRefs.join(',')) {
                                    issuePatterns.absoluteRefIssues.push({
                                        sheet: sheetName,
                                        cell: origCell.address,
                                        original: origFormula,
                                        imported: impFormula,
                                        originalRefs: absRefs,
                                        importedRefs: impAbsRefs
                                    });
                                }
                            } else {
                                issuePatterns.changedFormulas.push({
                                    sheet: sheetName,
                                    cell: origCell.address,
                                    original: origFormula,
                                    imported: impFormula,
                                    exported: expFormula
                                });
                            }
                        }
                    }
                });
            });
            
            // Generate focused report
            report.push('ISSUE SUMMARY:');
            report.push('-'.repeat(30));
            report.push(`Missing formulas: ${issuePatterns.missingFormulas.length}`);
            report.push(`Changed formulas: ${issuePatterns.changedFormulas.length}`);
            report.push(`CHOOSE formula issues: ${issuePatterns.chooseFormulaIssues.length}`);
            report.push(`Absolute ref issues: ${issuePatterns.absoluteRefIssues.length}`);
            report.push(`Other issues: ${issuePatterns.otherIssues.length}`);
            report.push('');
            
            // Report CHOOSE formula issues (most important)
            if (issuePatterns.chooseFormulaIssues.length > 0) {
                report.push('CHOOSE FORMULA ISSUES:');
                report.push('-'.repeat(30));
                
                // Group by pattern
                const choosePatterns = {};
                issuePatterns.chooseFormulaIssues.forEach(issue => {
                    // Extract the reference pattern (e.g., $E16 vs $E17)
                    const origRef = (issue.original.match(/\$[A-Z]+\$?\d+/) || [''])[0];
                    const impRef = issue.imported ? (issue.imported.match(/\$[A-Z]+\$?\d+/) || [''])[0] : '';
                    const pattern = `${origRef} → ${impRef}`;
                    
                    if (!choosePatterns[pattern]) {
                        choosePatterns[pattern] = [];
                    }
                    choosePatterns[pattern].push(issue);
                });
                
                Object.keys(choosePatterns).forEach(pattern => {
                    const examples = choosePatterns[pattern];
                    report.push(`\nPattern: ${pattern} (${examples.length} occurrences)`);
                    report.push('First 3 examples:');
                    examples.slice(0, 3).forEach(ex => {
                        report.push(`  ${ex.sheet}!${ex.cell}:`);
                        report.push(`    Original: ${ex.original}`);
                        report.push(`    Imported: ${ex.imported || 'MISSING'}`);
                        if (ex.exported && ex.exported !== ex.imported) {
                            report.push(`    Exported: ${ex.exported}`);
                        }
                    });
                });
                report.push('');
            }
            
            // Report absolute reference issues
            if (issuePatterns.absoluteRefIssues.length > 0) {
                report.push('ABSOLUTE REFERENCE ISSUES:');
                report.push('-'.repeat(30));
                
                // Show first 5 examples
                issuePatterns.absoluteRefIssues.slice(0, 5).forEach(issue => {
                    report.push(`${issue.sheet}!${issue.cell}:`);
                    report.push(`  Original refs: ${issue.originalRefs.join(', ')}`);
                    report.push(`  Imported refs: ${issue.importedRefs.join(', ')}`);
                    report.push(`  Original: ${issue.original}`);
                    report.push(`  Imported: ${issue.imported}`);
                    report.push('');
                });
                
                if (issuePatterns.absoluteRefIssues.length > 5) {
                    report.push(`... and ${issuePatterns.absoluteRefIssues.length - 5} more`);
                }
                report.push('');
            }
            
            // Report other changed formulas (first 5)
            if (issuePatterns.changedFormulas.length > 0) {
                report.push('OTHER FORMULA CHANGES (first 5):');
                report.push('-'.repeat(30));
                
                issuePatterns.changedFormulas.slice(0, 5).forEach(issue => {
                    report.push(`${issue.sheet}!${issue.cell}:`);
                    report.push(`  Original: ${issue.original}`);
                    report.push(`  Imported: ${issue.imported || 'MISSING'}`);
                    if (issue.exported && issue.exported !== issue.imported) {
                        report.push(`  Exported: ${issue.exported}`);
                    }
                    report.push('');
                });
                
                if (issuePatterns.changedFormulas.length > 5) {
                    report.push(`... and ${issuePatterns.changedFormulas.length - 5} more`);
                }
            }
            
            // Missing formulas summary
            if (issuePatterns.missingFormulas.length > 0) {
                report.push('');
                report.push('MISSING FORMULAS (first 10):');
                report.push('-'.repeat(30));
                issuePatterns.missingFormulas.slice(0, 10).forEach(issue => {
                    report.push(`${issue.sheet}!${issue.cell}: ${issue.original}`);
                });
                if (issuePatterns.missingFormulas.length > 10) {
                    report.push(`... and ${issuePatterns.missingFormulas.length - 10} more`);
                }
            }
            
            report.push('');
            report.push('=' .repeat(50));
            report.push('END OF REPORT');
            
            reportContent = report.join('\n');
            
            // Show preview
            document.getElementById('preview').textContent = reportContent;
        }

        function downloadReport() {
            if (!reportContent) {
                alert('No report to download. Run analysis first.');
                return;
            }
            
            const blob = new Blob([reportContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `excel-diff-report-${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>